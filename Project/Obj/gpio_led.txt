; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\gpio_led.o --depend=.\Obj\gpio_led.d --device=DARMSTM --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\User -I..\BaseDrive -Id:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\gpio_led.crf ..\BaseDrive\Gpio_Led.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GpioLed_Init PROC
;;;26     *******************************************************************************************/
;;;27     void GpioLed_Init(void)
000000  b508              PUSH     {r3,lr}
;;;28     {
;;;29       	GPIO_InitTypeDef GPIO_InitStructure;
;;;30       
;;;31     	RCC_APB2PeriphClockCmd(LED1_RCC_APB2Periph , ENABLE);// 使能APB2外设LED1时钟
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;32     	RCC_APB2PeriphClockCmd(LED2_RCC_APB2Periph , ENABLE);// 使能APB2外设LED2时钟
00000a  2101              MOVS     r1,#1
00000c  2080              MOVS     r0,#0x80
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;33     	RCC_APB2PeriphClockCmd(LED3_RCC_APB2Periph , ENABLE);// 使能APB2外设LED3时钟
000012  2101              MOVS     r1,#1
000014  2080              MOVS     r0,#0x80
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;34     
;;;35       	GPIO_InitStructure.GPIO_Pin	= LED1_GPIO_Pin;         //选择led1
00001a  2040              MOVS     r0,#0x40
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;36       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
000020  2003              MOVS     r0,#3
000022  f88d0002          STRB     r0,[sp,#2]
;;;37       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //模式为推挽输出
000026  2010              MOVS     r0,#0x10
000028  f88d0003          STRB     r0,[sp,#3]
;;;38       	GPIO_Init(LED1_GPIO, &GPIO_InitStructure);           //初始化led1寄存器
00002c  4669              MOV      r1,sp
00002e  4881              LDR      r0,|L1.564|
000030  f7fffffe          BL       GPIO_Init
;;;39     
;;;40       	GPIO_InitStructure.GPIO_Pin	= LED2_GPIO_Pin;         //选择led2
000034  2080              MOVS     r0,#0x80
000036  f8ad0000          STRH     r0,[sp,#0]
;;;41       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
00003a  2003              MOVS     r0,#3
00003c  f88d0002          STRB     r0,[sp,#2]
;;;42       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //模式为推挽输出
000040  2010              MOVS     r0,#0x10
000042  f88d0003          STRB     r0,[sp,#3]
;;;43       	GPIO_Init(LED2_GPIO, &GPIO_InitStructure);           //初始化led2寄存器
000046  4669              MOV      r1,sp
000048  487a              LDR      r0,|L1.564|
00004a  f7fffffe          BL       GPIO_Init
;;;44     
;;;45     	GPIO_InitStructure.GPIO_Pin	= LED3_GPIO_Pin;         //选择led3
00004e  f44f7080          MOV      r0,#0x100
000052  f8ad0000          STRH     r0,[sp,#0]
;;;46       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 	 //管脚频率为50MHZ
000056  2003              MOVS     r0,#3
000058  f88d0002          STRB     r0,[sp,#2]
;;;47       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //模式为推挽输出
00005c  2010              MOVS     r0,#0x10
00005e  f88d0003          STRB     r0,[sp,#3]
;;;48       	GPIO_Init(LED3_GPIO, &GPIO_InitStructure);           //初始化led3寄存器
000062  4669              MOV      r1,sp
000064  4873              LDR      r0,|L1.564|
000066  f7fffffe          BL       GPIO_Init
;;;49     }
00006a  bd08              POP      {r3,pc}
;;;50     
                          ENDP

                  Delay PROC
;;;59     *******************************************************************************************/
;;;60     static void Delay(u32 counter)
00006c  bf00              NOP      
                  |L1.110|
;;;61     {
;;;62     	while(counter--);
00006e  0001              MOVS     r1,r0
000070  f1a00001          SUB      r0,r0,#1
000074  d1fb              BNE      |L1.110|
;;;63     }
000076  4770              BX       lr
;;;64     
                          ENDP

                  LED_Display PROC
;;;73     *******************************************************************************************/
;;;74     void LED_Display(void)
000078  b510              PUSH     {r4,lr}
;;;75     {
;;;76         GPIO_SetBits(LED1_GPIO,LED1_GPIO_Pin);
00007a  2140              MOVS     r1,#0x40
00007c  486d              LDR      r0,|L1.564|
00007e  f7fffffe          BL       GPIO_SetBits
;;;77     	Delay(0xfffff);
000082  486d              LDR      r0,|L1.568|
000084  f7fffffe          BL       Delay
;;;78     	GPIO_ResetBits(LED1_GPIO,LED1_GPIO_Pin);
000088  2140              MOVS     r1,#0x40
00008a  486a              LDR      r0,|L1.564|
00008c  f7fffffe          BL       GPIO_ResetBits
;;;79     
;;;80     	GPIO_SetBits(LED2_GPIO,LED2_GPIO_Pin);
000090  2180              MOVS     r1,#0x80
000092  4868              LDR      r0,|L1.564|
000094  f7fffffe          BL       GPIO_SetBits
;;;81     	Delay(0xfffff);
000098  4867              LDR      r0,|L1.568|
00009a  f7fffffe          BL       Delay
;;;82     	GPIO_ResetBits(LED2_GPIO,LED2_GPIO_Pin);
00009e  2180              MOVS     r1,#0x80
0000a0  4864              LDR      r0,|L1.564|
0000a2  f7fffffe          BL       GPIO_ResetBits
;;;83     
;;;84     	GPIO_SetBits(LED3_GPIO,LED3_GPIO_Pin);
0000a6  f44f7180          MOV      r1,#0x100
0000aa  4862              LDR      r0,|L1.564|
0000ac  f7fffffe          BL       GPIO_SetBits
;;;85     	Delay(0xfffff);
0000b0  4861              LDR      r0,|L1.568|
0000b2  f7fffffe          BL       Delay
;;;86     	GPIO_ResetBits(LED3_GPIO,LED3_GPIO_Pin);
0000b6  f44f7180          MOV      r1,#0x100
0000ba  485e              LDR      r0,|L1.564|
0000bc  f7fffffe          BL       GPIO_ResetBits
;;;87     }
0000c0  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  Key_Init PROC
;;;97     *******************************************************************************************/
;;;98     void Key_Init(void)
0000c2  b508              PUSH     {r3,lr}
;;;99     {
;;;100      	GPIO_InitTypeDef GPIO_InitStructure;
;;;101      
;;;102    	RCC_APB2PeriphClockCmd(KEY1_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY1时钟
0000c4  2101              MOVS     r1,#1
0000c6  2004              MOVS     r0,#4
0000c8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;103    	RCC_APB2PeriphClockCmd(KEY2_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY2时钟
0000cc  2101              MOVS     r1,#1
0000ce  2020              MOVS     r0,#0x20
0000d0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;104    	RCC_APB2PeriphClockCmd(KEY3_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY3时钟
0000d4  2101              MOVS     r1,#1
0000d6  2004              MOVS     r0,#4
0000d8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;105    
;;;106      	GPIO_InitStructure.GPIO_Pin	= KEY1_GPIO_Pin;         //选择KEY1
0000dc  f44f7080          MOV      r0,#0x100
0000e0  f8ad0000          STRH     r0,[sp,#0]
;;;107      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
;;;108      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
0000e4  2004              MOVS     r0,#4
0000e6  f88d0003          STRB     r0,[sp,#3]
;;;109      	GPIO_Init(KEY1_GPIO, &GPIO_InitStructure);           //初始化KEY1寄存器
0000ea  4669              MOV      r1,sp
0000ec  4853              LDR      r0,|L1.572|
0000ee  f7fffffe          BL       GPIO_Init
;;;110    
;;;111      	GPIO_InitStructure.GPIO_Pin	= KEY2_GPIO_Pin;         //选择KEY2
0000f2  2008              MOVS     r0,#8
0000f4  f8ad0000          STRH     r0,[sp,#0]
;;;112      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
;;;113      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
0000f8  2004              MOVS     r0,#4
0000fa  f88d0003          STRB     r0,[sp,#3]
;;;114      	GPIO_Init(KEY2_GPIO, &GPIO_InitStructure);           //初始化KEY2寄存器
0000fe  4669              MOV      r1,sp
000100  484f              LDR      r0,|L1.576|
000102  f7fffffe          BL       GPIO_Init
;;;115    
;;;116    	GPIO_InitStructure.GPIO_Pin	= KEY3_GPIO_Pin;         //选择KEY3
000106  2001              MOVS     r0,#1
000108  f8ad0000          STRH     r0,[sp,#0]
;;;117      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 	 //管脚频率为50MHZ
;;;118      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
00010c  2004              MOVS     r0,#4
00010e  f88d0003          STRB     r0,[sp,#3]
;;;119      	GPIO_Init(KEY3_GPIO, &GPIO_InitStructure);           //初始化KEY3寄存器
000112  4669              MOV      r1,sp
000114  4849              LDR      r0,|L1.572|
000116  f7fffffe          BL       GPIO_Init
;;;120    }
00011a  bd08              POP      {r3,pc}
;;;121    
                          ENDP

                  Key_Test PROC
;;;130    *******************************************************************************************/
;;;131    void Key_Test(void)
00011c  b510              PUSH     {r4,lr}
;;;132    {
;;;133        /***************按键1的测试********************/
;;;134    	if(GPIO_ReadInputDataBit(KEY1_GPIO,KEY1_GPIO_Pin) == Bit_RESET)
00011e  f44f7180          MOV      r1,#0x100
000122  4846              LDR      r0,|L1.572|
000124  f7fffffe          BL       GPIO_ReadInputDataBit
000128  b920              CBNZ     r0,|L1.308|
;;;135    	{
;;;136    	    GPIO_ResetBits(LED1_GPIO,LED1_GPIO_Pin);    
00012a  2140              MOVS     r1,#0x40
00012c  4841              LDR      r0,|L1.564|
00012e  f7fffffe          BL       GPIO_ResetBits
000132  e00a              B        |L1.330|
                  |L1.308|
;;;137    	}
;;;138    	else if(GPIO_ReadInputDataBit(KEY1_GPIO,KEY1_GPIO_Pin) == Bit_SET)
000134  f44f7180          MOV      r1,#0x100
000138  4840              LDR      r0,|L1.572|
00013a  f7fffffe          BL       GPIO_ReadInputDataBit
00013e  2801              CMP      r0,#1
000140  d103              BNE      |L1.330|
;;;139    	{
;;;140    	    GPIO_SetBits(LED1_GPIO,LED1_GPIO_Pin);    
000142  2140              MOVS     r1,#0x40
000144  483b              LDR      r0,|L1.564|
000146  f7fffffe          BL       GPIO_SetBits
                  |L1.330|
;;;141    	}
;;;142    	/***************按键2的测试********************/
;;;143    	if(GPIO_ReadInputDataBit(KEY2_GPIO,KEY2_GPIO_Pin) == Bit_RESET)
00014a  2108              MOVS     r1,#8
00014c  483c              LDR      r0,|L1.576|
00014e  f7fffffe          BL       GPIO_ReadInputDataBit
000152  b990              CBNZ     r0,|L1.378|
;;;144    	{
;;;145    	    Delay(0xfffff);
000154  4838              LDR      r0,|L1.568|
000156  f7fffffe          BL       Delay
;;;146    		if(GPIO_ReadInputDataBit(KEY2_GPIO,KEY2_GPIO_Pin) == Bit_RESET)
00015a  2108              MOVS     r1,#8
00015c  4838              LDR      r0,|L1.576|
00015e  f7fffffe          BL       GPIO_ReadInputDataBit
000162  b950              CBNZ     r0,|L1.378|
;;;147    		{
;;;148    		    if(key_info.Key2_state == true)
000164  4837              LDR      r0,|L1.580|
000166  7840              LDRB     r0,[r0,#1]  ; key_info
000168  2801              CMP      r0,#1
00016a  d103              BNE      |L1.372|
;;;149    			    key_info.Key2_state = false;
00016c  2000              MOVS     r0,#0
00016e  4935              LDR      r1,|L1.580|
000170  7048              STRB     r0,[r1,#1]
000172  e002              B        |L1.378|
                  |L1.372|
;;;150    			else
;;;151    				key_info.Key2_state = true;
000174  2001              MOVS     r0,#1
000176  4933              LDR      r1,|L1.580|
000178  7048              STRB     r0,[r1,#1]
                  |L1.378|
;;;152    		}		
;;;153    	}
;;;154    
;;;155    	if(key_info.Key2_state == true)
00017a  4832              LDR      r0,|L1.580|
00017c  7840              LDRB     r0,[r0,#1]  ; key_info
00017e  2801              CMP      r0,#1
000180  d104              BNE      |L1.396|
;;;156    	    GPIO_ResetBits(LED2_GPIO,LED2_GPIO_Pin);
000182  2180              MOVS     r1,#0x80
000184  482b              LDR      r0,|L1.564|
000186  f7fffffe          BL       GPIO_ResetBits
00018a  e003              B        |L1.404|
                  |L1.396|
;;;157    	else 
;;;158    		GPIO_SetBits(LED2_GPIO,LED2_GPIO_Pin);
00018c  2180              MOVS     r1,#0x80
00018e  4829              LDR      r0,|L1.564|
000190  f7fffffe          BL       GPIO_SetBits
                  |L1.404|
;;;159    
;;;160        /***************按键3的测试********************/
;;;161    	if(GPIO_ReadInputDataBit(KEY3_GPIO,KEY3_GPIO_Pin) == Bit_RESET)
000194  2101              MOVS     r1,#1
000196  4829              LDR      r0,|L1.572|
000198  f7fffffe          BL       GPIO_ReadInputDataBit
00019c  b998              CBNZ     r0,|L1.454|
;;;162    	{
;;;163    	    Delay(0xffff);
00019e  f64f70ff          MOV      r0,#0xffff
0001a2  f7fffffe          BL       Delay
;;;164    		if(GPIO_ReadInputDataBit(KEY3_GPIO,KEY3_GPIO_Pin) == Bit_RESET)
0001a6  2101              MOVS     r1,#1
0001a8  4824              LDR      r0,|L1.572|
0001aa  f7fffffe          BL       GPIO_ReadInputDataBit
0001ae  b950              CBNZ     r0,|L1.454|
;;;165    		{
;;;166    		    if(key_info.Key3_state == true)
0001b0  4824              LDR      r0,|L1.580|
0001b2  7880              LDRB     r0,[r0,#2]  ; key_info
0001b4  2801              CMP      r0,#1
0001b6  d103              BNE      |L1.448|
;;;167    			    key_info.Key3_state = false;
0001b8  2000              MOVS     r0,#0
0001ba  4922              LDR      r1,|L1.580|
0001bc  7088              STRB     r0,[r1,#2]
0001be  e002              B        |L1.454|
                  |L1.448|
;;;168    			else
;;;169    				key_info.Key3_state = true;
0001c0  2001              MOVS     r0,#1
0001c2  4920              LDR      r1,|L1.580|
0001c4  7088              STRB     r0,[r1,#2]
                  |L1.454|
;;;170    		}		
;;;171    	}
;;;172    
;;;173    	key_info.Counter2 += 0xfff;
0001c6  481f              LDR      r0,|L1.580|
0001c8  6880              LDR      r0,[r0,#8]  ; key_info
0001ca  f60070ff          ADD      r0,r0,#0xfff
0001ce  491d              LDR      r1,|L1.580|
0001d0  6088              STR      r0,[r1,#8]  ; key_info
;;;174    	if(key_info.Counter2 > 0x2fffff)
0001d2  4608              MOV      r0,r1
0001d4  6880              LDR      r0,[r0,#8]  ; key_info
0001d6  f5b01f40          CMP      r0,#0x300000
0001da  d301              BCC      |L1.480|
;;;175        key_info.Counter2 = 0;
0001dc  2000              MOVS     r0,#0
0001de  6088              STR      r0,[r1,#8]  ; key_info
                  |L1.480|
;;;176    
;;;177    	if(key_info.Key3_state == true)
0001e0  4818              LDR      r0,|L1.580|
0001e2  7880              LDRB     r0,[r0,#2]  ; key_info
0001e4  2801              CMP      r0,#1
0001e6  d11f              BNE      |L1.552|
;;;178    	{
;;;179    	    key_info.Counter1 += 1;
0001e8  4816              LDR      r0,|L1.580|
0001ea  6840              LDR      r0,[r0,#4]  ; key_info
0001ec  1c40              ADDS     r0,r0,#1
0001ee  4915              LDR      r1,|L1.580|
0001f0  6048              STR      r0,[r1,#4]  ; key_info
;;;180    		if(key_info.Counter1 > 0x2ff)
0001f2  4608              MOV      r0,r1
0001f4  6840              LDR      r0,[r0,#4]  ; key_info
0001f6  f5b07f40          CMP      r0,#0x300
0001fa  d301              BCC      |L1.512|
;;;181    		    key_info.Counter1 = 0;
0001fc  2000              MOVS     r0,#0
0001fe  6048              STR      r0,[r1,#4]  ; key_info
                  |L1.512|
;;;182    		
;;;183    		if(key_info.Counter2 > key_info.Counter1 * 0xfff)
000200  4810              LDR      r0,|L1.580|
000202  6880              LDR      r0,[r0,#8]  ; key_info
000204  490f              LDR      r1,|L1.580|
000206  6849              LDR      r1,[r1,#4]  ; key_info
000208  ebc13101          RSB      r1,r1,r1,LSL #12
00020c  4288              CMP      r0,r1
00020e  d905              BLS      |L1.540|
;;;184    		    GPIO_SetBits(LED3_GPIO,LED3_GPIO_Pin);
000210  f44f7180          MOV      r1,#0x100
000214  4807              LDR      r0,|L1.564|
000216  f7fffffe          BL       GPIO_SetBits
00021a  e00a              B        |L1.562|
                  |L1.540|
;;;185    		else
;;;186    		    GPIO_ResetBits(LED3_GPIO,LED3_GPIO_Pin);
00021c  f44f7180          MOV      r1,#0x100
000220  4804              LDR      r0,|L1.564|
000222  f7fffffe          BL       GPIO_ResetBits
000226  e004              B        |L1.562|
                  |L1.552|
;;;187    	}
;;;188    	else
;;;189    	    GPIO_SetBits(LED3_GPIO,LED3_GPIO_Pin);
000228  f44f7180          MOV      r1,#0x100
00022c  4801              LDR      r0,|L1.564|
00022e  f7fffffe          BL       GPIO_SetBits
                  |L1.562|
;;;190    }
000232  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  |L1.564|
                          DCD      0x40011c00
                  |L1.568|
                          DCD      0x000fffff
                  |L1.572|
                          DCD      0x40010800
                  |L1.576|
                          DCD      0x40011400
                  |L1.580|
                          DCD      key_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  key_info
                          %        12
