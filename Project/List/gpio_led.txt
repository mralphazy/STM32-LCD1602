; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\gpio_led.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\gpio_led.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\User -I..\BaseDrive -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\gpio_led.crf ..\BaseDrive\Gpio_Led.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GpioLed_Init PROC
;;;26     *******************************************************************************************/
;;;27     void GpioLed_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;28     {
;;;29     	u16 i,PinNum;
;;;30     	GPIO_InitTypeDef GPIO_InitStructure;	//结构声明
;;;31     	RCC_APB2PeriphClockCmd(Data_RCC_APB2Periph , ENABLE);// 使能APB2外设LED1时钟
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;32     	for (i=0;i<11;i++)
00000a  2400              MOVS     r4,#0
00000c  e011              B        |L1.50|
                  |L1.14|
;;;33     	{
;;;34     		PinNum = 1;
00000e  2501              MOVS     r5,#1
;;;35     		PinNum = PinNum<<i;
000010  fa05f004          LSL      r0,r5,r4
000014  b285              UXTH     r5,r0
;;;36     		GPIO_InitStructure.GPIO_Pin	= PinNum; 
000016  f8ad5000          STRH     r5,[sp,#0]
;;;37     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
00001a  2003              MOVS     r0,#3
00001c  f88d0002          STRB     r0,[sp,#2]
;;;38     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	 //模式为推挽输出
000020  2010              MOVS     r0,#0x10
000022  f88d0003          STRB     r0,[sp,#3]
;;;39     		GPIO_Init(IO_LCD, &GPIO_InitStructure);           //初始化led1寄存器
000026  4669              MOV      r1,sp
000028  488a              LDR      r0,|L1.596|
00002a  f7fffffe          BL       GPIO_Init
00002e  1c60              ADDS     r0,r4,#1              ;32
000030  b284              UXTH     r4,r0                 ;32
                  |L1.50|
000032  2c0b              CMP      r4,#0xb               ;32
000034  dbeb              BLT      |L1.14|
;;;40     	}
;;;41     }
000036  bd38              POP      {r3-r5,pc}
;;;42     
                          ENDP

                  WriteData_8 PROC
;;;51     *******************************************************************************************/
;;;52     void WriteData_8(u8 Data_8)
000038  b570              PUSH     {r4-r6,lr}
;;;53     {
00003a  4605              MOV      r5,r0
;;;54     	u8 PinNum =1,i;
00003c  2401              MOVS     r4,#1
;;;55     	for (i = 0;i<8;i++ )
00003e  2600              MOVS     r6,#0
000040  e017              B        |L1.114|
                  |L1.66|
;;;56     	{
;;;57     		if ((PinNum&Data_8)==PinNum)
000042  ea040005          AND      r0,r4,r5
000046  42a0              CMP      r0,r4
000048  d105              BNE      |L1.86|
;;;58     		{
;;;59     			GPIO_WriteBit(GPIOF,PinNum,Bit_SET);
00004a  2201              MOVS     r2,#1
00004c  4621              MOV      r1,r4
00004e  4881              LDR      r0,|L1.596|
000050  f7fffffe          BL       GPIO_WriteBit
000054  e009              B        |L1.106|
                  |L1.86|
;;;60     		}
;;;61     		else if ((PinNum&Data_8) == ~PinNum)
000056  ea040005          AND      r0,r4,r5
00005a  43e1              MVNS     r1,r4
00005c  4288              CMP      r0,r1
00005e  d104              BNE      |L1.106|
;;;62     		{
;;;63     			GPIO_WriteBit(GPIOF,PinNum,Bit_RESET);
000060  2200              MOVS     r2,#0
000062  4621              MOV      r1,r4
000064  487b              LDR      r0,|L1.596|
000066  f7fffffe          BL       GPIO_WriteBit
                  |L1.106|
;;;64     		}
;;;65     		PinNum = PinNum<<1;
00006a  0660              LSLS     r0,r4,#25
00006c  0e04              LSRS     r4,r0,#24
00006e  1c70              ADDS     r0,r6,#1              ;55
000070  b2c6              UXTB     r6,r0                 ;55
                  |L1.114|
000072  2e08              CMP      r6,#8                 ;55
000074  dbe5              BLT      |L1.66|
;;;66     	}
;;;67     }
000076  bd70              POP      {r4-r6,pc}
;;;68     
                          ENDP

                  ReadData_8 PROC
;;;77     *******************************************************************************************/
;;;78     u8 ReadData_8(void)
000078  b570              PUSH     {r4-r6,lr}
;;;79     {
;;;80     	//u8 PinNum =1,i;
;;;81     	u16	PinVal;
;;;82     	u8 DataVal;
;;;83     	//WriteData_8(0xff);
;;;84     	PinVal = GPIO_ReadInputData(GPIOF);
00007a  4876              LDR      r0,|L1.596|
00007c  f7fffffe          BL       GPIO_ReadInputData
000080  4604              MOV      r4,r0
;;;85     	DataVal = PinVal;
000082  b2e5              UXTB     r5,r4
;;;86     	return DataVal;
000084  4628              MOV      r0,r5
;;;87     }
000086  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP

                  Delay PROC
;;;97     *******************************************************************************************/
;;;98     static void Delay(u32 counter)
000088  bf00              NOP      
                  |L1.138|
;;;99     {
;;;100    	while(counter--);
00008a  0001              MOVS     r1,r0
00008c  f1a00001          SUB      r0,r0,#1
000090  d1fb              BNE      |L1.138|
;;;101    }
000092  4770              BX       lr
;;;102    
                          ENDP

                  LED_Display PROC
;;;111    *******************************************************************************************/
;;;112    void LED_Display(void)
000094  b510              PUSH     {r4,lr}
;;;113    {
;;;114    	GPIO_SetBits(IO_LCD,RS);
000096  f44f7180          MOV      r1,#0x100
00009a  486e              LDR      r0,|L1.596|
00009c  f7fffffe          BL       GPIO_SetBits
;;;115    	Delay(0xfffff);
0000a0  486d              LDR      r0,|L1.600|
0000a2  f7fffffe          BL       Delay
;;;116    	GPIO_ResetBits(IO_LCD,RS);
0000a6  f44f7180          MOV      r1,#0x100
0000aa  486a              LDR      r0,|L1.596|
0000ac  f7fffffe          BL       GPIO_ResetBits
;;;117    
;;;118    	GPIO_SetBits(IO_LCD,RW);
0000b0  f44f7100          MOV      r1,#0x200
0000b4  4867              LDR      r0,|L1.596|
0000b6  f7fffffe          BL       GPIO_SetBits
;;;119    	Delay(0xfffff);
0000ba  4867              LDR      r0,|L1.600|
0000bc  f7fffffe          BL       Delay
;;;120    	GPIO_ResetBits(IO_LCD,RW);
0000c0  f44f7100          MOV      r1,#0x200
0000c4  4863              LDR      r0,|L1.596|
0000c6  f7fffffe          BL       GPIO_ResetBits
;;;121    
;;;122    	GPIO_SetBits(IO_LCD,EN);
0000ca  f44f6180          MOV      r1,#0x400
0000ce  4861              LDR      r0,|L1.596|
0000d0  f7fffffe          BL       GPIO_SetBits
;;;123    	Delay(0xfffff);
0000d4  4860              LDR      r0,|L1.600|
0000d6  f7fffffe          BL       Delay
;;;124    	GPIO_ResetBits(IO_LCD,EN);
0000da  f44f6180          MOV      r1,#0x400
0000de  485d              LDR      r0,|L1.596|
0000e0  f7fffffe          BL       GPIO_ResetBits
;;;125    }
0000e4  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  Key_Init PROC
;;;135    *******************************************************************************************/
;;;136    void Key_Init(void)
0000e6  b508              PUSH     {r3,lr}
;;;137    {
;;;138      	GPIO_InitTypeDef GPIO_InitStructure;
;;;139      
;;;140    	RCC_APB2PeriphClockCmd(KEY1_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY1时钟
0000e8  2101              MOVS     r1,#1
0000ea  2004              MOVS     r0,#4
0000ec  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;141    	RCC_APB2PeriphClockCmd(KEY2_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY2时钟
0000f0  2101              MOVS     r1,#1
0000f2  2020              MOVS     r0,#0x20
0000f4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;142    	RCC_APB2PeriphClockCmd(KEY3_RCC_APB2Periph , ENABLE);// 使能APB2外设KEY3时钟
0000f8  2101              MOVS     r1,#1
0000fa  2004              MOVS     r0,#4
0000fc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;143    
;;;144      	GPIO_InitStructure.GPIO_Pin	= KEY1_GPIO_Pin;         //选择KEY1
000100  f44f7080          MOV      r0,#0x100
000104  f8ad0000          STRH     r0,[sp,#0]
;;;145      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
;;;146      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
000108  2004              MOVS     r0,#4
00010a  f88d0003          STRB     r0,[sp,#3]
;;;147      	GPIO_Init(KEY1_GPIO, &GPIO_InitStructure);           //初始化KEY1寄存器
00010e  4669              MOV      r1,sp
000110  4852              LDR      r0,|L1.604|
000112  f7fffffe          BL       GPIO_Init
;;;148    
;;;149      	GPIO_InitStructure.GPIO_Pin	= KEY2_GPIO_Pin;         //选择KEY2
000116  2008              MOVS     r0,#8
000118  f8ad0000          STRH     r0,[sp,#0]
;;;150      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //管脚频率为50MHZ
;;;151      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
00011c  2004              MOVS     r0,#4
00011e  f88d0003          STRB     r0,[sp,#3]
;;;152      	GPIO_Init(KEY2_GPIO, &GPIO_InitStructure);           //初始化KEY2寄存器
000122  4669              MOV      r1,sp
000124  484e              LDR      r0,|L1.608|
000126  f7fffffe          BL       GPIO_Init
;;;153    
;;;154    	GPIO_InitStructure.GPIO_Pin	= KEY3_GPIO_Pin;         //选择KEY3
00012a  2001              MOVS     r0,#1
00012c  f8ad0000          STRH     r0,[sp,#0]
;;;155      	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 	 //管脚频率为50MHZ
;;;156      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//模式为输入浮空
000130  2004              MOVS     r0,#4
000132  f88d0003          STRB     r0,[sp,#3]
;;;157      	GPIO_Init(KEY3_GPIO, &GPIO_InitStructure);           //初始化KEY3寄存器
000136  4669              MOV      r1,sp
000138  4848              LDR      r0,|L1.604|
00013a  f7fffffe          BL       GPIO_Init
;;;158    }
00013e  bd08              POP      {r3,pc}
;;;159    
                          ENDP

                  Key_Test PROC
;;;168    *******************************************************************************************/
;;;169    void Key_Test(void)
000140  b510              PUSH     {r4,lr}
;;;170    {
;;;171        /***************按键1的测试********************/
;;;172    	if(GPIO_ReadInputDataBit(KEY1_GPIO,KEY1_GPIO_Pin) == Bit_RESET)
000142  f44f7180          MOV      r1,#0x100
000146  4845              LDR      r0,|L1.604|
000148  f7fffffe          BL       GPIO_ReadInputDataBit
00014c  b920              CBNZ     r0,|L1.344|
;;;173    	{
;;;174    	    GPIO_ResetBits(IO_LCD,D0);    
00014e  2101              MOVS     r1,#1
000150  4840              LDR      r0,|L1.596|
000152  f7fffffe          BL       GPIO_ResetBits
000156  e00a              B        |L1.366|
                  |L1.344|
;;;175    	}
;;;176    	else if(GPIO_ReadInputDataBit(KEY1_GPIO,KEY1_GPIO_Pin) == Bit_SET)
000158  f44f7180          MOV      r1,#0x100
00015c  483f              LDR      r0,|L1.604|
00015e  f7fffffe          BL       GPIO_ReadInputDataBit
000162  2801              CMP      r0,#1
000164  d103              BNE      |L1.366|
;;;177    	{
;;;178    	    GPIO_SetBits(IO_LCD,D0);    
000166  2101              MOVS     r1,#1
000168  483a              LDR      r0,|L1.596|
00016a  f7fffffe          BL       GPIO_SetBits
                  |L1.366|
;;;179    	}
;;;180    	/***************按键2的测试********************/
;;;181    	if(GPIO_ReadInputDataBit(KEY2_GPIO,KEY2_GPIO_Pin) == Bit_RESET)
00016e  2108              MOVS     r1,#8
000170  483b              LDR      r0,|L1.608|
000172  f7fffffe          BL       GPIO_ReadInputDataBit
000176  b990              CBNZ     r0,|L1.414|
;;;182    	{
;;;183    	    Delay(0xfffff);
000178  4837              LDR      r0,|L1.600|
00017a  f7fffffe          BL       Delay
;;;184    		if(GPIO_ReadInputDataBit(KEY2_GPIO,KEY2_GPIO_Pin) == Bit_RESET)
00017e  2108              MOVS     r1,#8
000180  4837              LDR      r0,|L1.608|
000182  f7fffffe          BL       GPIO_ReadInputDataBit
000186  b950              CBNZ     r0,|L1.414|
;;;185    		{
;;;186    		    if(key_info.Key2_state == true)
000188  4836              LDR      r0,|L1.612|
00018a  7840              LDRB     r0,[r0,#1]  ; key_info
00018c  2801              CMP      r0,#1
00018e  d103              BNE      |L1.408|
;;;187    			    key_info.Key2_state = false;
000190  2000              MOVS     r0,#0
000192  4934              LDR      r1,|L1.612|
000194  7048              STRB     r0,[r1,#1]
000196  e002              B        |L1.414|
                  |L1.408|
;;;188    			else
;;;189    				key_info.Key2_state = true;
000198  2001              MOVS     r0,#1
00019a  4932              LDR      r1,|L1.612|
00019c  7048              STRB     r0,[r1,#1]
                  |L1.414|
;;;190    		}		
;;;191    	}
;;;192    
;;;193    	if(key_info.Key2_state == true)
00019e  4831              LDR      r0,|L1.612|
0001a0  7840              LDRB     r0,[r0,#1]  ; key_info
0001a2  2801              CMP      r0,#1
0001a4  d104              BNE      |L1.432|
;;;194    	    GPIO_ResetBits(IO_LCD,D1);
0001a6  2102              MOVS     r1,#2
0001a8  482a              LDR      r0,|L1.596|
0001aa  f7fffffe          BL       GPIO_ResetBits
0001ae  e003              B        |L1.440|
                  |L1.432|
;;;195    	else 
;;;196    		GPIO_SetBits(IO_LCD,D1);
0001b0  2102              MOVS     r1,#2
0001b2  4828              LDR      r0,|L1.596|
0001b4  f7fffffe          BL       GPIO_SetBits
                  |L1.440|
;;;197    
;;;198        /***************按键3的测试********************/
;;;199    	if(GPIO_ReadInputDataBit(IO_LCD,D3) == Bit_RESET)
0001b8  2108              MOVS     r1,#8
0001ba  4826              LDR      r0,|L1.596|
0001bc  f7fffffe          BL       GPIO_ReadInputDataBit
0001c0  b998              CBNZ     r0,|L1.490|
;;;200    	{
;;;201    	    Delay(0xffff);
0001c2  f64f70ff          MOV      r0,#0xffff
0001c6  f7fffffe          BL       Delay
;;;202    		if(GPIO_ReadInputDataBit(IO_LCD,D3) == Bit_RESET)
0001ca  2108              MOVS     r1,#8
0001cc  4821              LDR      r0,|L1.596|
0001ce  f7fffffe          BL       GPIO_ReadInputDataBit
0001d2  b950              CBNZ     r0,|L1.490|
;;;203    		{
;;;204    		    if(key_info.Key3_state == true)
0001d4  4823              LDR      r0,|L1.612|
0001d6  7880              LDRB     r0,[r0,#2]  ; key_info
0001d8  2801              CMP      r0,#1
0001da  d103              BNE      |L1.484|
;;;205    			    key_info.Key3_state = false;
0001dc  2000              MOVS     r0,#0
0001de  4921              LDR      r1,|L1.612|
0001e0  7088              STRB     r0,[r1,#2]
0001e2  e002              B        |L1.490|
                  |L1.484|
;;;206    			else
;;;207    				key_info.Key3_state = true;
0001e4  2001              MOVS     r0,#1
0001e6  491f              LDR      r1,|L1.612|
0001e8  7088              STRB     r0,[r1,#2]
                  |L1.490|
;;;208    		}		
;;;209    	}
;;;210    
;;;211    	key_info.Counter2 += 0xfff;
0001ea  481e              LDR      r0,|L1.612|
0001ec  6880              LDR      r0,[r0,#8]  ; key_info
0001ee  f60070ff          ADD      r0,r0,#0xfff
0001f2  491c              LDR      r1,|L1.612|
0001f4  6088              STR      r0,[r1,#8]  ; key_info
;;;212    	if(key_info.Counter2 > 0x2fffff)
0001f6  4608              MOV      r0,r1
0001f8  6880              LDR      r0,[r0,#8]  ; key_info
0001fa  f5b01f40          CMP      r0,#0x300000
0001fe  d301              BCC      |L1.516|
;;;213        key_info.Counter2 = 0;
000200  2000              MOVS     r0,#0
000202  6088              STR      r0,[r1,#8]  ; key_info
                  |L1.516|
;;;214    
;;;215    	if(key_info.Key3_state == true)
000204  4817              LDR      r0,|L1.612|
000206  7880              LDRB     r0,[r0,#2]  ; key_info
000208  2801              CMP      r0,#1
00020a  d11d              BNE      |L1.584|
;;;216    	{
;;;217    	    key_info.Counter1 += 1;
00020c  4815              LDR      r0,|L1.612|
00020e  6840              LDR      r0,[r0,#4]  ; key_info
000210  1c40              ADDS     r0,r0,#1
000212  4914              LDR      r1,|L1.612|
000214  6048              STR      r0,[r1,#4]  ; key_info
;;;218    		if(key_info.Counter1 > 0x2ff)
000216  4608              MOV      r0,r1
000218  6840              LDR      r0,[r0,#4]  ; key_info
00021a  f5b07f40          CMP      r0,#0x300
00021e  d301              BCC      |L1.548|
;;;219    		    key_info.Counter1 = 0;
000220  2000              MOVS     r0,#0
000222  6048              STR      r0,[r1,#4]  ; key_info
                  |L1.548|
;;;220    		
;;;221    		if(key_info.Counter2 > key_info.Counter1 * 0xfff)
000224  480f              LDR      r0,|L1.612|
000226  6880              LDR      r0,[r0,#8]  ; key_info
000228  490e              LDR      r1,|L1.612|
00022a  6849              LDR      r1,[r1,#4]  ; key_info
00022c  ebc13101          RSB      r1,r1,r1,LSL #12
000230  4288              CMP      r0,r1
000232  d904              BLS      |L1.574|
;;;222    		    GPIO_SetBits(IO_LCD,D3);
000234  2108              MOVS     r1,#8
000236  4807              LDR      r0,|L1.596|
000238  f7fffffe          BL       GPIO_SetBits
00023c  e008              B        |L1.592|
                  |L1.574|
;;;223    		else
;;;224    		    GPIO_ResetBits(IO_LCD,D3);
00023e  2108              MOVS     r1,#8
000240  4804              LDR      r0,|L1.596|
000242  f7fffffe          BL       GPIO_ResetBits
000246  e003              B        |L1.592|
                  |L1.584|
;;;225    	}
;;;226    	else
;;;227    	    GPIO_SetBits(IO_LCD,D3);
000248  2108              MOVS     r1,#8
00024a  4802              LDR      r0,|L1.596|
00024c  f7fffffe          BL       GPIO_SetBits
                  |L1.592|
;;;228    }
000250  bd10              POP      {r4,pc}
;;;229    
                          ENDP

000252  0000              DCW      0x0000
                  |L1.596|
                          DCD      0x40011c00
                  |L1.600|
                          DCD      0x000fffff
                  |L1.604|
                          DCD      0x40010800
                  |L1.608|
                          DCD      0x40011400
                  |L1.612|
                          DCD      key_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  key_info
                          %        12
